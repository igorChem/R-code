{
    "contents" : "# Packages e funções para leitura e carregamento de imagens; \n# interpolações, predições, plots e etc.. \n\n# 1. Leitura/carregamento de imagens \n# 2. Summary of imagens\n# 3. criação e manipulação de imagens \n# 4. Plots imagens \n# 5. geoStatistics \n# 6.\n\n## 1. Leitura/carregamento de imagens\n\n\n# rgdal (exemplos)\n#Read/write between GDAL grid maps and Spatial objects\nlibrary(rgdal)\nlibrary(grid)\nGDALinfo(system.file(\"external/test.ag\", package=\"sp\")[1]) # testar essa função \nx <- readGDAL(system.file(\"external/test.ag\", package=\"sp\")[1]) # read/load spatial data, o plot não funciona; spplot e image funcionam\nclass(x)\nimage(x)\nsummary(x)\nx@data[[1]][x@data[[1]] > 10000] <- NA\nsummary(x)\nimage(x)\n\n\n# readOGR {rgdal} (exemplos)\n# Read OGR vector maps into Spatial objects\n\nogrDrivers() # informa quais são os formatos que podem ser lifod com a função OGR #reads the origin of the data source and creates an spatial object\ndsn <- system.file(\"vectors\", package = \"rgdal\")[1] # reads and stores the data file name in an object \nogrListLayers(dsn) # reads and informs the names of layers  \nogrInfo(dsn=dsn, layer=\"cities\") # information about a specific layer\nowd <- getwd() # getwd retrieves the working directory ## importante para os testes \nsetwd(dsn) # setwd sets the working directory ## importante para os testes\ncities <- readOGR(dsn=dsn, layer=\"cities\") # le os points da layer\nplot(cities)\nsummary(cities)\n\n\n\nogrInfo(dsn=dsn, layer=\"kiritimati_primary_roads\")\nOGRSpatialRef(dsn=dsn, layer=\"kiritimati_primary_roads\")# informa o sistema de referência de cordenadas\nkiritimati_primary_roads <- readOGR(dsn=dsn, layer=\"kiritimati_primary_roads\")\nsummary(kiritimati_primary_roads)\nogrInfo(dsn=dsn, layer=\"scot_BNG\")\nOGRSpatialRef(dsn=dsn, layer=\"scot_BNG\")\nscot_BNG <- readOGR(dsn=dsn, layer=\"scot_BNG\")\nsummary(scot_BNG)\nplot(scot_BNG)\n\n\n#readShapeSpatial {maptools}\tR Documentation\n#Read shape files into Spatial*DataFrame objects\n\n# melhor função para dados espaciais, por enquanto\n\nlibrary(maptools)\nxx <- readShapeSpatial(system.file(\"shapes/sids.shp\", package=\"maptools\")[1],\n                       IDvar=\"FIPSNO\", proj4string=CRS(\"+proj=longlat +ellps=clrk66\"))\nsummary(xx)\nspplot(xx)\n\n# raster {raster}\t\n# Create a RasterLayer object\n\n\n# Create a RasterLayer object from a file\n#   N.B.: For your own files, omit the 'system.file' and 'package=\"raster\"' bits\n#   these are just to get the path to files installed with the package\n\nf <- system.file(\"external/test.grd\", package=\"raster\") # retrieving the filename from the file in the package dir\nf\nr <- raster(f)\n\nlogo <- raster(system.file(\"external/rlogo.grd\", package=\"raster\")) \n\n#from scratch\nr1 <- raster(nrows=108, ncols=21, xmn=0, xmx=10)\nsummary(r1)\nr1\n#from an Extent object\ne <- extent(r)\nr2 <- raster(e)\nr2\n#from another Raster* object\nr3 <- raster(r)\ns <- stack(r, r, r)\nr4 <- raster(s)\nr5 <- raster(s, 3)\nr3\nr4\nr5\n\n# rasterFromXYZ {raster}\tR Documentation\n#Create a Raster* object from x, y, z values\n\n#Create a Raster* object from x, y and z values. x and y represent spatial coordinates and must be on a regular grid\n\nr <- raster(nrow=1000, ncol=1000, extent(t001), crs=NA)\nr[] <- runif(ncell(r))\nr[r<0.5] <- NA\nxyz <- rasterToPoints(r)\n\nr2 <- rasterFromXYZ(xyz) #Raster to point conversion. Cells with NA are not converted. A function can be used to select a subset of the raster cells (by their values).\nplot(r2)\nr4 <-dropLayer(r2,c(1))\n## 3. criação/manipulação de imagens\n# extent {raster}\t\n# Extent\n\nr <- raster() # criou um raster com o default da função \nextent(r)\nextent(c(0, 20, 0, 20))\n#is equivalent to\nextent(0, 20, 0, 20)\nextent(matrix(c(0, 0, 20, 20), nrow=2))\nx <- list(x=c(0,1,2), y=c(-3,5))\nextent(x)\n# gridded função para verificar se a matriz é grid ou não\n\nx <- readGDAL(system.file(\"external/simple.ag\", package=\"sp\")[1])\nclass(x)\nimage(x)\nsummary(x)\nx <- readGDAL(system.file(\"pictures/big_int_arc_file.asc\", package=\"rgdal\")[1])\nsummary(x)\ncat(\"if the range is not 10000, 77590, your GDAL does not detect big\\n\")\ncat(\"integers for this driver\\n\")\ny = readGDAL(system.file(\"pictures/Rlogo.jpg\", package = \"rgdal\")[1], band=1)\nsummary(y)\ny = readGDAL(system.file(\"pictures/Rlogo.jpg\", package = \"rgdal\")[1])\nsummary(y)\nspplot(y, names.attr=c(\"red\",\"green\",\"blue\"), \n       col.regions=grey(0:100/100),\n       main=\"example of three-layer (RGB) raster image\", as.table=TRUE)\ndata(meuse.grid)\ngridded(meuse.grid) = ~x+y\nproj4string(meuse.grid) = CRS(\"+init=epsg:28992\")\nfn <- tempfile()\nwriteGDAL(meuse.grid[\"dist\"], fn)\nGDALinfo(fn)\nwriteGDAL(meuse.grid[\"dist\"], fn, setStatistics=TRUE)\nGDALinfo(fn)\nmg2 <- readGDAL(fn)\nproj4string(mg2)\nSP27GTIF <- readGDAL(system.file(\"pictures/SP27GTIF.TIF\", \n                                 package = \"rgdal\")[1], output.dim=c(100,100))\nsummary(SP27GTIF)\nimage(SP27GTIF, col=grey(1:99/100))\n\n\n# stack {raster}\tR Documentation\n# Create a RasterStack object\n\n# file with one layer\nfn <- system.file(\"external/test.grd\", package=\"raster\")\ns <- stack(fn, fn)\nr <- raster(fn)\nextent(s)\ns <- stack(r, fn)\nnlayers(s)\n\n# file with three layers\nslogo <- stack(system.file(\"external/rlogo.grd\", package=\"raster\")) \nnlayers(slogo) # conta o número de layers\nslogo\n\n\n#brick {raster}\t\n#Create a RasterBrick object\n\nb <- brick(system.file(\"external/rlogo.grd\", package=\"raster\"))\nb\nnlayers(b)\nnames(b)\nextract(b, 870) # extrai valores de objetos dos layers\n\n#rasterize {raster}\t(exemplos)\n#Rasterize points, lines, or polygons\n\n#rasterize points\n###############################\nr <- raster(ncols=36, nrows=18)\nn <- 1000\nx <- runif(n) * 360 - 180 # These functions provide information about the uniform distribution on the interval from min to max. dunif gives the density, punif gives the distribution function qunif gives the quantile function and runif generates random deviates\ny <- runif(n) * 180 - 90\nxy <- cbind(x, y)\n# get the (last) indices\nr0 <- rasterize(xy, r)\nplot(r0)\n# prensence/absensce (NA) (is there a point or not?)\nr1 <- rasterize(xy, r, field=1)\nplot(r1)\n# how many points?\nr2 <- rasterize(xy, r, fun=function(x,...)length(x))\nvals <- runif(n)\nplot(r2)\n# sum of the values associated with the points\nr3 <- rasterize(xy, r, vals, fun=sum)\n\n\n#subset Subset layers in a Raster* object\n\ns <- stack(system.file(\"external/rlogo.grd\", package=\"raster\"))\nsel <- subset(s, 2:3) # selecionando só o segundo e o terceiro layer\n\n# Note that this is equivalent to\nsel2 <- s[[2:3]]\n# and in this particular case:\nsel3 <- dropLayer(s, 1)\nnlayers(s)\nnlayers(sel)\n\n# effect of drop=FALSE when selecting a single layer\nsel <- subset(s, 2)\nclass(sel)\nsel <- subset(s, 2, drop=FALSE)\nclass(sel)\n\n#addLayer {raster} \n# Add or drop a layer\n\nfile <- system.file(\"external/test.grd\", package=\"raster\")\ns <- stack(file, file, file)\nr <- raster(file)\ns <- addLayer(s, r/2, r*2) # add layers, in this case the layesr that are function of an raster\ns\ns <- dropLayer(s, c(3, 5)) # drop epecific layers \nnlayers(s)\n\n#Unstack\n#Description\n#Create a list of RasterLayer objects from a RasterStack or RasterBrick\nfile <- system.file(\"external/test.grd\", package=\"raster\")\ns <- stack(file, file)\nlist1 <- unstack(s)\nb <- brick(s)\nlist2 <- unstack(b)\n\n#merge {raster}\t\n#Merge Raster* objects\n\nr1 <- raster(xmx=-150, ymn=60, ncols=30, nrows=30) # criou um raster \nr1[] <- 1:ncell(r1) # adiciona valores ás células \nr2 <- raster(xmn=-100, xmx=-50, ymx=50, ymn=30) # criou o segundo objeto \nres(r2) <- c(xres(r1), yres(r1)) # copiou a resolução do r1 para o r2\nr2[] <- 1:ncell(r2) # adicionaou valores na célula\nrm <- merge(r1, r2)\nplot(r1)\nplot(r2)\nplot(rm)\n\n# if you have many RasterLayer objects in a list\n# you can use do.call:\nx <- list(r1, r2) # create a list of raster objects \n# add arguments such as filename\n# x$filename <- 'test.tif'\nm <- do.call(merge, x) #do.call constructs and executes a function call from a name or a function and a list of arguments to be passed to it.\n\n#mosaic {raster}\t\n# Merge Raster* objects using a function for overlapping areas\n\nr <- raster(ncol=100, nrow=100)\nr1 <- crop(r, extent(-10, 11, -10, 11)) # change the extent of the rasterfile\nr2 <- crop(r, extent(0, 20, 0, 20))\nr3 <- crop(r, extent(9, 30, 9, 30))\n\nr1[] <- 1:ncell(r1) # adicionando valores ás células\nr2[] <- 1:ncell(r2)\nr3[] <- 1:ncell(r3)\n\nm1 <- mosaic(r1, r2, r3, fun=mean)\n\ns1 <- stack(r1, r1*2)\ns2 <- stack(r2, r2/2)\ns3 <- stack(r3, r3*4)\nm2 <- mosaic(s1, s2, s3, fun=min)\n\n\n\n# mask {raster}\t\n# Mask values in a Raster object\n\n\nr <- raster(ncol=10, nrow=10)\nm <- raster(ncol=10, nrow=10)\nr[] <- runif(ncell(r)) * 10\nm[] <- runif(ncell(r))\nm[m < 0.5] <- NA\nmr <- mask(r, m)\nmr\nplot(r)\nplot(m)\nplot(mr)\nm2 <- m > .7\nmr2 <- mask(r, m2, maskvalue=TRUE)\nplot(mr2)\n\n#  4. redict Spatial model predictions\n\nA simple model to predict the location of the R in the R-logo using 20 presence points \n# and 50 (random) pseudo-absence points. This type of model is often used to predict\n# species distributions. See the dismo package for more of that.\n\n# create a RasterStack or RasterBrick with with a set of predictor layers\nlogo <- brick(system.file(\"external/rlogo.grd\", package=\"raster\"))\nnames(logo)\n\n## Not run: \n# the predictor variables\n\npar(mfrow=c(2,2))\nplotRGB(logo, main='logo')\nplot(logo, 1, col=rgb(cbind(0:255,0,0), maxColorValue=255))\nplot(logo, 2, col=rgb(cbind(0,0:255,0), maxColorValue=255))\nplot(logo, 3, col=rgb(cbind(0,0,0:255), maxColorValue=255))\npar(mfrow=c(1,1))\n# End(Not run)\n\n# known presence and absence of points\np <- matrix(c(48, 48, 48, 53, 50, 46, 54, 70, 84, 85, 74, 84, 95, 85, \n              66, 42, 26, 4, 19, 17, 7, 14, 26, 29, 39, 45, 51, 56, 46, 38, 31, \n              22, 34, 60, 70, 73, 63, 46, 43, 28), ncol=2) # matriz 2x2 \n\na <- matrix(c(22, 33, 64, 85, 92, 94, 59, 27, 30, 64, 60, 33, 31, 9,\n              99, 67, 15, 5, 4, 30, 8, 37, 42, 27, 19, 69, 60, 73, 3, 5, 21,\n              37, 52, 70, 74, 9, 13, 4, 17, 47), ncol=2) # matriz 2x2\n\n# extract values for points\nxy <- rbind(cbind(1, p), cbind(0, a))\nv <- data.frame(cbind(pa=xy[,1], extract(logo, xy[,2:3]))) # criando um subset com dados da imagem para criar o modelo\n\n#build a model, here an example with glm \nmodel <- glm(formula=pa~., data=v)\nsummary(model)\n#predict to a raster\nr1 <- predict(logo, model, progress='text') # prediz valores para a layer baseado em dados prévios da imagem. \n\nplot(r1)\npoints(p, bg='blue', pch=21) # coloca os pontos utilizados para a predição \npoints(a, bg='red', pch=21) \nr1 # raster resultado do modelo de predição \n\n\n# principal components of a RasterBrick\n# here using sampling to simulate an object too large\n# too feed all its values to prcomp\nsr <- sampleRandom(logo, 100) # legal isso, acho que vou precisar para os objetos de raster com muitas células\npca <- prcomp(sr)\nsummary(pca)\nlibrary(pls)\nloadings(pca)\nbiplot(pca)\n# note the use of the 'index' argument\nx <- predict(logo, pca, index=1:3)\nplot(x)\n# caralho, posso utilizar PCA para prever, muito bem!!\n\n# partial least square regression\nlibrary(pls)\nmodel <- plsr(formula=pa~., data=v)\n# this returns an array:\npredict(model, v[1:5,]) # interessante jeito de gerar dados para prever\n# write a function to turn that into a matrix\npfun <- function(x, data) {\n  y <- predict(x, data)\n  d <- dim(y)\n  dim(y) <- c(prod(d[1:2]), d[3])\n  y\n}\n\npp <- predict(logo, model, fun=pfun, index=1:3)\nplot(pp) # muito bom também, mas muito complexo. \n\n# Random Forest\n\nlibrary(randomForest)\nrfmod <- randomForest(pa ~., data=v)\n\n## note the additional argument \"type='response'\" that is \n## passed to predict.randomForest\nr3 <- predict(logo, rfmod, type='response', progress='window')\n\n# Random Forest\n\nlibrary(randomForest)\nrfmod <- randomForest(pa ~., data=v)\n\n## note the additional argument \"type='response'\" that is \n## passed to predict.randomForest\nr3 <- predict(logo, rfmod, type='response', progress='window')\n\n\n\n\n# interpolate {raster}\tR Documentation\n# Interpolate\n\n# Make a RasterLayer with interpolated values using a fitted model object of classes such as 'gstat' (gstat package) or 'Krige' (fields package)\n\n## Thin plate spline interpolation with x and y only\n# some example data\nr <- raster(system.file(\"external/test.grd\", package=\"raster\"))\nra <- aggregate(r, 10) # cria rasterlayer com menor número de células, maiores células\nxy <- data.frame(xyFromCell(ra, 1:ncell(ra))) # extrai valores de coodenadas de cćlulas e cria um data.frame\nv <- getValues(ra) # valores das células \n\n#### Thin plate spline model\nlibrary(fields) # package com os modelos de inerpolação\ntps <- Tps(xy, v) # modelo de interpolação, input e output\np <- raster(r) # MUITO IMPORTANTE, criou um raster sem valores mas com as informações epaciais do raster original\n\n# use model to predict values at all locations\np <- interpolate(p, tps) # usa o modelo de interpolação para criar os valores interpolados e colocalos como a layer \np1 <- mask(p, r) # cria mask para plotar somoente os valores que estão no território original.\n\nplot(p) # valores interpolados ocupando toda a extensão do raster\nplot(p1)\n\n## change the fun from predict to fields::predictSE to get the TPS standard error\nse <- interpolate(p, tps, fun=predictSE) # standard error \nse <- mask(se, r)\nplot(se)\n\n## another variable; let's call it elevation\nelevation <- (init(r, 'x') * init(r, 'y')) / 100000000\nnames(elevation) <- 'elev'\nelevation <- mask(elevation, r)\n\nz <- extract(elevation, xy)\n\n# add as another independent variable\nxyz <- cbind(xy, z)\ntps2 <- Tps(xyz, v)\np2 <- interpolate(elevation, tps2, xyOnly=FALSE)\n\n# as a linear coveriate\ntps3 <- Tps(xy, v, Z=z)\n\n# Z is a separate argument in Krig.predict, so we need a new function\n# Internally (in interpolate) a matrix is formed of x, y, and elev (Z)\n\npfun <- function(model, x, ...) {\n  predict(model, x[,1:2], Z=x[,3], ...)\n}\np3 <- interpolate(elevation, tps3, xyOnly=FALSE, fun=pfun)\nplot(p3)\n\n\n# interpolate with inverse distance weighting \n\n\nr <- raster(system.file(\"external/test.grd\", package=\"raster\")) # sistema de cordenadas de referências em graus \ndata(meuse) # data frame\nmg <- gstat(id = \"zinc\", formula = zinc~1, locations = ~x+y, data=meuse,\nnmax=13, set=list(idp = .5)) # locations são as colunas da longitude e latitude na forma de formula \nz <- interpolate(r, mg) # usou o raster carregado para interpolar os valores \nz <- mask(z, r)\nplot(z)\nr\nhead(r)\n\n\n# interpolate with kriging\n## kriging\ncoordinates(meuse) <- ~x+y\nprojection(meuse) <- projection(r)\n## ordinary kriging\nv <- variogram(log(zinc)~1, meuse)\nm <- fit.variogram(v, vgm(1, \"Sph\", 300, 1))\ngOK <- gstat(NULL, \"log.zinc\", log(zinc)~1, meuse, model=m)\nOK <- interpolate(r, gOK)\n# examples below provided by Maurizio Marchi\n## universial kriging\nvu <- variogram(log(zinc)~elev, meuse)\nmu <- fit.variogram(vu, vgm(1, \"Sph\", 300, 1))\ngUK <- gstat(NULL, \"log.zinc\", log(zinc)~elev, meuse, model=mu)\nnames(r) <- elev\nUK <- interpolate(r, gUK, xyOnly=FALSE)\n\n\n\n\n# rastertopoints\nr <- raster(nrow=18, ncol=36)\nr[] <- runif(ncell(r)) * 10\nr[r>8] <- NA\np <- rasterToPoints(r)\np <- rasterToPoints(r, fun=function(x){x>6}) # pegou somente os pontos maiores que 6\nplot(r) # plot raster\npoints(p) # plot the points retrivied before\n\n## plot, raster package \n\n# RasterLayer\nr <- raster(nrows=10, ncols=10)\nr <- setValues(r, 1:ncell(r))\nplot(r)\n\ne <- extent(r)\nplot(e, add=TRUE, col='red', lwd=4) # cria linh que contona o extent\n\ne <- e / 2\nplot(e, add=TRUE, col='red')\n\n# Scatterplot of 2 RasterLayers\nr2 <- sqrt(r)\nplot(r, r2)\nplot(r, r2, gridded=TRUE) # da plotar uma layer contra a outra\n\n# Multi-layer object (RasterStack / Brick)\ns <- stack(r, r2, r/r)\nplot(s, 2)\nplot(s)\n\n\n# two objects, different range, one scale:\nr[] <- runif(ncell(r))\nr2 <- r/2\nbrks <- seq(0, 1, by=0.1) \nnb <- length(brks)-1 \ncols <- rev(terrain.colors(nb))\npar(mfrow=c(1,2))\nplot(r, breaks=brks, col=cols, lab.breaks=brks, zlim=c(0,1), main='first') \nplot(r2, breaks=brks, col=cols, lab.breaks=brks, zlim=c(0,1), main='second') \n\n# breaks and labels, \nx <- raster(nc=10, nr=10)\nx[] <- runif(ncell(x))\nbrk <- c(0, 0.25, 0.75, 1)\narg <- list(at=c(0.12,0.5,0.87), labels=c(\"Low\",\"Med.\",\"High\"))\nplot(x, col=terrain.colors(3), breaks=brk)\nplot(x, col=terrain.colors(3), breaks=brk, axis.args=arg)\npar(mfrow=c(1,1))\n\n# color ramp\nplot(x, col=colorRampPalette(c(\"red\", \"white\", \"blue\"))(255))\n\n\n# adding random points to the map\nxy <- cbind(-180 + runif(10) * 360, -90 + runif(10) * 180)\npoints(xy, pch=3, cex=5)\n\n# for SpatialPolygons do\n plot(pols, add=TRUE)\n\n# adding the same points to each map of each layer of a RasterStack\nfun <- function() {\n  points(xy, cex=2)\n  points(xy, pch=3, col='red')\n}\nplot(s, addfun=fun)\n\n\n#spplot {raster}\t\n# Use spplot to plot a Raster* object\n\nr <- raster(system.file(\"external/test.grd\", package=\"raster\"))\ns <- stack(r, r*2)\nnames(s) <- c('meuse', 'meuse x 2')\n\nspplot(s)\n\npts <- data.frame(sampleRandom(r, 10, xy=TRUE))\ncoordinates(pts) <- ~ x + y\n\nspplot(s, scales = list(draw = TRUE), \n       xlab = \"easting\", ylab = \"northing\", \n       col.regions = rainbow(99, start=.1), \n       names.attr=c('original', 'times two'),\n       sp.layout = list(\"sp.points\", pts, pch=20, cex=2, col='black'),\n       par.settings = list(fontsize = list(text = 12)), at = seq(0, 4000, 500))\n\n\n\n#setValues {raster}\t\n#Set values of a Raster object\n\nr <- raster(ncol=10, nrow=10)\nvals <- 1:ncell(r)\nr <- setValues(r, vals)\n# equivalent to\nr[] <- vals\nr\n\n\n#bind {raster}\t\n#Bind Spatial* objects\n\n#Bind (append) Spatial* objects into a single object. All objects must be of the same vector type base class (SpatialPoints, SpatialLines, or SpatialPolygons)\n\nif (require(rgdal) & require(rgeos)) {\n  p <- shapefile(system.file(\"external/lux.shp\", package=\"raster\"))\n  mersch <- p[p$NAME_2=='Mersch', ]\n  diekirch <- p[p$NAME_2=='Diekirch', ]\n  remich <- p[p$NAME_2=='Remich', ]\n  remich$NAME_1 <- NULL\n  x <- bind(mersch, diekirch, remich)\n  plot(x)\n  data.frame(x)\n}\n\n\n\n#compassRose compassRose Display a compass rose\n\ncompassRose(x,y,rot=0,cex=1)\n\n# coordinates {sp}\tR Documentation\n# setdata(meuse.grid)\n\n# data.frame\ndata(meuse.grid)\ncoordinates(meuse.grid) <- ~x+y\ngridded(meuse.grid) <- TRUE\nclass(meuse.grid)\nbbox(meuse.grid)\nplot(meuse.grid)\nhead(meuse.grid)\n\ndata(meuse)\nmeuse.xy = meuse[c(\"x\", \"y\")]\ncoordinates(meuse.xy) <- ~x+y\nclass(meuse.xy)\nplot(meuse.xy)\nmeuse.rs <- raster(meuse.grid)\nmeuse.rs\n\n\n## sp package\n\n# gridded\n\n\n# just 9 points on a grid:\nx <- c(1,1,1,2,2,2,3,3,3)\ny <- c(1,2,3,1,2,3,1,2,3)\nxy <- cbind(x,y)\nS <- SpatialPoints(xy) # tranformou matrix em spatial objetic\nclass(S)\nplot(S)\ngridded(S) <- TRUE # transformou em spatial pixels \ngridded(S) # verificou se é gridded\nclass(S)\nsummary(S)\nplot(S) # diferença do primeiro plot, agora é um grid \ngridded(S) <- FALSE # transformou dde spatial pixels pra grid novamente \ngridded(S)\nclass(S)\n\n\n# as.SpatialPolygons.GridTopology {sp}\tR Documentation\n# Make SpatialPolygons object from GridTopology object\n\ndata(meuse.grid)\ngridded(meuse.grid)=~x+y\nxx = spsample(meuse.grid,  type=\"hexagonal\", cellsize=200)\nxxpl = HexPoints2SpatialPolygons(xx)\nimage(meuse.grid[\"dist\"])\nplot(xxpl, add = TRUE)\npoints(xx, cex = .5)\n## Not run: \nspplot(aggregate(meuse.grid[,1:3], xxpl), main = \"aggregated meuse.grid\")\n\n\n\n\ndata(meuse)\ncoordinates(meuse) <- c(\"x\", \"y\") # promote to SpatialPointsDataFrame\nbubble(meuse, \"cadmium\", maxsize = 2.5, main = \"cadmium concentrations (ppm)\",\n       key.entries = 2^(-1:4))\nbubble(meuse, \"zinc\", main = \"zinc concentrations (ppm)\",\n       key.entries = 100 * 2^(0:4))\n\n## gstat package \n\n# krige {gstat}\n\nlibrary(sp)\ndata(meuse)\ncoordinates(meuse) = ~x+y\ndata(meuse.grid)\nsummary(meuse.grid)\ngridded(meuse.grid) = ~x+y\nm <- vgm(.59, \"Sph\", 874, .04)\n# ordinary kriging:\nx <- krige(log(zinc)~1, meuse, meuse.grid, model = m)\nspplot(x[\"var1.pred\"], main = \"ordinary kriging predictions\")\nspplot(x[\"var1.var\"],  main = \"ordinary kriging variance\")\n# simple kriging:\nx <- krige(log(zinc)~1, meuse, meuse.grid, model = m, beta = 5.9)\n# residual variogram:\nm <- vgm(.4, \"Sph\", 954, .06)\n# universal block kriging:\nx <- krige(log(zinc)~x+y, meuse, meuse.grid, model = m, block = c(40,40))\nspplot(x[\"var1.pred\"], main = \"universal kriging predictions\")\n\n\n\n\n\n",
    "created" : 1455737191097.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1896529949",
    "id" : "BF21CC80",
    "lastKnownWriteTime" : 1455995864,
    "path" : "~/r/Rlearning/raster.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}